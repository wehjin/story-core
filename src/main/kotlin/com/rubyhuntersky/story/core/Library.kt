/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
@file:Suppress("EXPERIMENTAL_API_USAGE")

package com.rubyhuntersky.story.core

import com.rubyhuntersky.story.core.scopes.MatchedScope
import com.rubyhuntersky.story.core.scopes.MatchingScope
import com.rubyhuntersky.story.core.scopes.StoryOverScope
import com.rubyhuntersky.story.core.scopes.StoryUpdateScope
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.channels.ConflatedBroadcastChannel
import kotlinx.coroutines.channels.ReceiveChannel
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlin.math.absoluteValue
import kotlin.random.Random

fun <V : Any> matchingStory(
    name: String,
    init: V,
    isOver: (V) -> Boolean,
    updateRules: suspend MatchingScope<V>.() -> Unit
) = story(name, init, isOver) { action ->
    var nextVision: V? = null
    object : MatchingScope<V> {
        override fun <A : Any, W : V> match(
            actionClass: Class<A>,
            visionClass: Class<W>,
            update: MatchedScope<A, W>.() -> V
        ) {
            if (nextVision == null) {
                if (actionClass.isInstance(action) && visionClass.isInstance(vision)) {
                    val matchedAction = actionClass.cast(action)!!
                    val matchedVision = visionClass.cast(vision)!!
                    nextVision = MatchedScope(matchedAction, matchedVision).update()
                }
            }
        }
    }.apply { runBlocking { updateRules() } }
    nextVision
}

interface Story<V : Any> {
    val name: String
    val number: Long
    fun isStoryOver(vision: V): Boolean
    fun subscribe(): ReceiveChannel<V>
    fun offer(action: Any)
}

fun <V : Any> story(
    name: String,
    init: V,
    isOver: (V) -> Boolean,
    toNextVision: StoryUpdateScope<V>.(action: Any) -> V?
): Story<V> = object : Story<V> {
    override val name: String = name
    override val number: Long = Random.nextLong().absoluteValue

    private val coroutineScope = GlobalScope
    private val visions = ConflatedBroadcastChannel(init)
    private val actions = Channel<Any>(5)

    init {
        coroutineScope.launch {
            for (action in actions) {
                visions.value.let { vision ->
                    val nextVision = object : StoryUpdateScope<V> {
                        override val storyName = name
                        override val vision = vision
                        override val offer = actions::offer
                        override fun <W : Any> atStoryEnd(substory: Story<W>, block: StoryOverScope<W>.() -> Unit) {
                            coroutineScope.launch {
                                for (subvision in substory.subscribe()) {
                                    if (substory.isStoryOver(subvision)) {
                                        object : StoryOverScope<W> {
                                            override val ending: W? = subvision
                                        }.block()
                                        break
                                    }
                                }
                            }
                        }
                    }.toNextVision(action)
                    nextVision?.let { visions.send(it) }
                }
            }
        }
    }

    override fun isStoryOver(vision: V): Boolean = isOver(vision)
    override fun subscribe(): ReceiveChannel<V> = visions.openSubscription()
    override fun offer(action: Any) {
        actions.offer(action)
    }
}
