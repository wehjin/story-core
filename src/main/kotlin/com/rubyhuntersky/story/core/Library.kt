/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
@file:Suppress("EXPERIMENTAL_API_USAGE")

package com.rubyhuntersky.story.core

import com.rubyhuntersky.story.core.scopes.*
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.channels.ConflatedBroadcastChannel
import kotlinx.coroutines.channels.ReceiveChannel
import kotlinx.coroutines.channels.sendBlocking
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlin.math.absoluteValue
import kotlin.random.Random

fun <V : Any> matchingStory(
    name: String,
    toFirstVision: StoryInitScope<V>.() -> V,
    isLastVision: (V) -> Boolean,
    updateRules: suspend MatchingScope<V>.() -> Unit
) = story(
    name = name,
    isLastVision = isLastVision,
    toFirstVision = toFirstVision,
    toNextVision = { action: Any ->

        var nextVision: V? = null
        object : MatchingScope<V> {
            override fun <A : Any, W : V> match(
                actionClass: Class<A>,
                visionClass: Class<W>,
                update: MatchedScope<A, V, W>.() -> V
            ) {
                if (nextVision == null) {
                    if (actionClass.isInstance(action) && visionClass.isInstance(vision)) {
                        val matchedAction = actionClass.cast(action)!!
                        val matchedVision = visionClass.cast(vision)!!
                        nextVision = object : MatchedScope<A, V, W> {
                            override val action: A = matchedAction
                            override val vision: W = matchedVision
                            override val storyName: String = this@story.storyName
                            override val offer: (action: Any) -> Boolean = this@story.offer
                            override fun <W : Any> whenSubstoryEnds(
                                substory: Story<W>,
                                block: StoryOverScope<W>.() -> Unit
                            ) = this@story.whenSubstoryEnds(substory, block)
                        }.update()
                    }
                }
            }
        }.apply { runBlocking { updateRules() } }
        nextVision
    }
)

interface Story<V : Any> {
    val name: String
    val number: Long
    fun isStoryOver(vision: V): Boolean
    fun subscribe(): ReceiveChannel<V>
    fun offer(action: Any)
}

fun <V : Any> story(
    name: String,
    isLastVision: (V) -> Boolean,
    toFirstVision: StoryInitScope<V>.() -> V,
    toNextVision: StoryUpdateScope<V>.(action: Any) -> V?
): Story<V> = object : Story<V> {
    private val coroutineScope = GlobalScope

    override val name: String = name
    override val number: Long = Random.nextLong().absoluteValue
    private val actions = Channel<Any>(5)
    private val visions = ConflatedBroadcastChannel<V>()

    init {
        coroutineScope.launch {
            val firstVision = object : StoryInitScope<V> {
                override val storyName: String = name
                override val offer: (action: Any) -> Boolean = actions::offer
                override fun <W : Any> whenSubstoryEnds(
                    substory: Story<W>,
                    block: StoryOverScope<W>.() -> Unit
                ) = runWhenSubstoryEnds(substory, block)
            }.toFirstVision()
            visions.sendBlocking(firstVision)
            for (action in actions) {
                visions.value.let { vision ->
                    val nextVision = object : StoryUpdateScope<V> {
                        override val storyName = name
                        override val vision = vision
                        override val offer = actions::offer
                        override fun <W : Any> whenSubstoryEnds(
                            substory: Story<W>,
                            block: StoryOverScope<W>.() -> Unit
                        ) = runWhenSubstoryEnds(substory, block)
                    }.toNextVision(action)
                    nextVision?.let { visions.send(it) }
                }
            }
        }
    }

    private fun <W : Any> runWhenSubstoryEnds(substory: Story<W>, block: StoryOverScope<W>.() -> Unit) {
        coroutineScope.launch {
            for (subvision in substory.subscribe()) {
                if (substory.isStoryOver(subvision)) {
                    object : StoryOverScope<W> {
                        override val ending: W? = subvision
                    }.block()
                    break
                }
            }
        }
    }

    override fun isStoryOver(vision: V): Boolean = isLastVision(vision)
    override fun subscribe(): ReceiveChannel<V> = visions.openSubscription()
    override fun offer(action: Any) {
        actions.offer(action)
    }
}

val neverEnds = { _: Any -> false }